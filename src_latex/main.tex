\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{natbib}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\sloppy


\title{Задача об оптимальном расписании}
\author{Гриб Александр}
\date{Октябрь 2020}

\begin{document}
\raggedright

\setlength{\parindent}{5ex}
\setlength{\parskip}{1em}
\newtheorem{theorem}{Теорема} 
\newtheorem{statement}{Утверждение}
\newtheorem{definition}{Определение}
\renewcommand{\proofname}{Доказательство}

\maketitle

% skip abstract title
\renewcommand{\abstractname}{\vspace{-\baselineskip}}
\begin{abstract}
В проекте рассмотрена задача об оптимальном расписании, когда производительность всех машин одинакова. Так же данная задача называется задачей многопроцессорного планирования. Доказана \textbf{NP}-полнота, построен эвристический алгоритм и показано что он дает $\frac{4}{3}$-приближение
\end{abstract}
\section*{Введение}
Пусть имеется множество работ \textit{J} и множество машин \textit{M}. Также задана функция \textit{p}: $J\times M \rightarrow \mathbb{R}_+$. Значение $p_{ij}$ означает время выполнение \textit{i}-ой работы на \textit{j}-ой машине. Требуется построить распределение работ по машинам так, чтобы все работы были выполнены и чтобы конечное время выполнения всех работ было минимально. То есть требуется найти функцию $x : J \times M \rightarrow \{0, 1\}$ такую, что:

$$\sum_{j \in M}{x_{ij}} = 1, \textup{для всех } i$$

$$\max_{j \in M} \sum_i{x_{ij}p_{ij}} \rightarrow min$$

В дальнейшем будем рассматривать частный случай задачи, когда производительности всех машин одинаковы, то есть $p_{ij} = p_i$. 

Данная задача также называется задачей многопроцессорного планирования и используется для распределения задач на кластерах с большим количеством почти одинаковых процессоров

Как будет показано далее, задача является \textbf{NP}-полной и существует полиномиальный алгоритм дающий $\left(\frac{4}{3} - \frac{1}{3m}\right) \textup{-приближение, где } m - \textup{количество машин}$ 

\section*{\textbf{NP}-полнота}

\newcommand{\MultiprocessorScheduling}{\textsf{MULTIPROCESSOR-SCHEDULING }}

Обозначим язык $$\{(T, m, k)\ |\ \textup{на $m$ машинах можно выполнить все задачи из $T$ за время} \leq k\}$$ как \MultiprocessorScheduling

\begin{statement} \label{mulshed-np}
$\MultiprocessorScheduling \in \textbf{NP}$, так как сертификатом можно выбрать набор из чисел 1-$m$, где $i$-ое число обозначает, что $i$-ая задача выполняется на машине с этим номером. Теперь вернем 0, если есть машина на которой суммарное время $> k$ и 1 иначе. Проверка суммарного времени выполнения всех задач на каждой машине выполняется за линию.
\end{statement}

\begin{statement} \label{np-proof}
$A \leq_{p} B$, $A$ - \textbf{NP}-полная, $B \in \textbf{NP}$ $\Rightarrow$ $B$ - \textbf{NP}-полный
\end{statement}

\begin{proof}
Доказывается по определению \textbf{NP}-полной задачи и транзитивности сводимости по Карпу. Если любая задача C из \textbf{NP} такая, что $C \leq_{p} A$ (из определения \textbf{NP}-полной задачи) и $A \leq_{p} B$ (из условия), то $C \leq_{p} B$ и $B \in \textbf{NP}$ (из условия), то по определению $B$ - \textbf{NP}-полный
\end{proof}

\begin{definition}
\textsf{SUBSETSUM} = $\{(n_1, n_2, ..., n_k, N)\ |\textup{ из набора чисел $n_1$, ..., $n_k$ можно
выбрать подмножество с суммой $N$}\}$
\end{definition}

\begin{theorem} \label{subsetsum-np-complete}
\textsf{SUBSETSUM} - \textbf{NP}-полный

Доказательство приведено в \citet*{subsetsum_np_complete}
\end{theorem}

Осталось доказать, что $\textsf{SUBSETSUM} \leq_p$ \MultiprocessorScheduling, тогда из \hyperref[mulshed-np]{\MultiprocessorScheduling $\in \textbf{NP}$}, \hyperref[subsetsum-np-complete]{\textsf{SUBSETSUM} --- \textbf{NP}-полный} и \hyperref[np-proof]{утверждению }\ref{np-proof} следует что \MultiprocessorScheduling --- \textbf{NP}-полный

\begin{theorem}
$\textsf{SUBSETSUM} \leq_p$ \MultiprocessorScheduling
\end{theorem}

\begin{proof}
Приведем полиномиально вычислимую функцию $f$ из $\textsf{SUBSETSUM}$ в \MultiprocessorScheduling.

1. Пусть $$\sum_{1 \leq i \leq k}{n_i} = 2N$$ Тогда f преобразует $(n_1, n_2, ..., n_k, N)$ в $((n_1, n_2, ..., n_k), 2, N)$ -- обозначим $Q$. И если $Q$ имеет решение в \MultiprocessorScheduling, то у нас есть 2 набора в каждом из которых сумма - $N$, а если решения \MultiprocessorScheduling нет, то никак нельзя поделить $(n_1, n_2, ..., n_k)$ на 2 множества по $N$ (иначе бы \MultiprocessorScheduling поделило бы и положила на 2 машины и $Q$ принадлежало бы \MultiprocessorScheduling).

2. Пусть $$\sum_{1 \leq i \leq k}{n_i} < 2N$$ Тогда f преобразует $(n_1, n_2, ..., n_k, N)$ в $\left(\left(n_1, n_2, ..., n_k, 2N - \sum_{1 \leq i \leq k}{n_i}\right), 2, N\right)$ -- обозначим $Q$. И если $Q$ имеет решение в \MultiprocessorScheduling, то у нас есть 2 набора в каждом из которых сумма - $N$. В одном из наборов лежит $n_{k+1}$, а второй состоит только из исходных элементов - его и берем как ответ. Обратное аналогично 1 пункту

3. Пусть $$\sum_{1 \leq i \leq k}{n_i} > 2N$$ Тогда f преобразует $(n_1, n_2, ..., n_k, N)$ в $\left(\left(n_1, n_2, ..., n_k, \sum_{1 \leq i \leq k}{n_i} - 2N\right),\ 2,\ \sum_{1 \leq i \leq k}{n_i} - N\right)$ -- обозначим $Q$. И если $Q$ имеет решение в \MultiprocessorScheduling, то у нас есть 2 набора в каждом из которых сумма - $\sum_{1 \leq i \leq k}{n_i} - N$. В одном из наборов лежит $n_{k+1}$. Убираем из этого набора $n_{k+1}$ и там остаются элементы в сумме дающие $\sum_{1 \leq i \leq k}{n_i} - N - \left(\sum_{1 \leq i \leq k}{n_i} - 2N\right) = N$. Вот мы и нашли нужное подмножество, которое дает в сумме $N$. Обратное аналогично 1 пункту

\end{proof}

\textbf{NP}-полнота доказана.

\section*{Эвристический алгоритм}

\textbf{Алгоритм}

1) Просортируем задачи по убыванию времени выполнения

2) Будем идти по отсортированному массиву и для задачи выбирать машину, где сейчас меньше всего суммарное время выполнения 

Время работы данного алгоритма при использовании кучи для поддержания машины с минимальным временем выполнения - $O(n(\log{n} + \log{m}))$. $\log{n}$ из-за сортировки и $\log{m}$ из-за того что для каждой задачи нужно выбрать машину из кучи с $m$ элементами.

\begin{theorem}
Данный алгоритм дает $\left(\frac{4}{3} - \frac{1}{3m}\right) \textup{-приближение, где } m - \textup{количество машин}$ оптимального расписания.
\end{theorem}

\begin{proof}
Многие идеи доказательства будут взяты из \citet{heuristic_algorithm_evaluation}. Так же в \citet{heuristic_algorithm_evaluation} можно найти пример показывающий что оценка точная и меньше взять нельзя.

Предположим противное, что существуют входные данные $[(T_1, T_2, T_3, ..., T_n), m]$ (сразу же перенумеруем T, так чтобы: $T_1 \geq T_2 \geq ... \geq T_n$), противоречащие условию, то есть если $\omega_O$ - оптимальное решение, а $\omega_L$ - решение нашим алгоритмом, то $\frac{\omega_L}{\omega_O} > \frac{4}{3} - \frac{1}{3m}$ и из всех таких наборов, возьмем тот у которого n - минимально.

Тогда заметим, что $n$-ая задача - единственная, которая заканчивается в $\omega_L$ в распределении задач нашим алгоритмом. Предположим противное, тогда существует $r < n$. Такая, что $r$-ая задача заканчивается в $\omega_L$, но тогда оставив только $(T_1, ..., T_r)$ не измениться $\omega_L$, а оптимальное решение не увеличится и значит $\frac{\omega_L}{\omega_O}$ будет больше $\frac{4}{3} - \frac{1}{3m}$ для $(T_1, ..., T_r)$ и это противоречит выбору входных данных с минимальным n.

Значит только $n$-ая задача заканчивается в $\omega_L$. Теперь пусть $\tau$ - время начала выполнения последней задачи в решении алгоритма

$$\omega_L = \tau + T_n$$

$$\sum_{i = 1}^{n-1}{T_i} \geq \tau m$$

Также $$\omega_O \geq \frac{1}{m}\sum_{i = 1}^{n}{T_i}$$ из того что оптимальное время больше чем время на каждом процессоре, а в сумме это время равно сумме времен всех задач.

$$\frac{\omega_L}{\omega_O} = \frac{\tau + T_n}{\omega_O} \leq \frac{T_n}{\omega_O} + \frac{\sum_{i = 1}^{n-1}{T_i}}{m\omega_O} = \frac{(m - 1)T_n}{m\omega_O} + \frac{\sum_{i = 1}^{n}{T_i}}{m\omega_O} \leq 1 + \frac{(m - 1)T_n}{m\omega_O}$$

С другой стороны, из предположения: $\frac{\omega_L}{\omega_O} > \frac{4}{3} - \frac{1}{3m}$

Значит $$1 + \frac{(m - 1)T_n}{m\omega_O} > \frac{4}{3} - \frac{1}{3m} = 1 + \frac{1}{3}(1 - \frac{1}{m})$$

$$\frac{(m - 1)T_n}{m\omega_O} > \frac{m - 1}{3m}$$

$$T_n > \frac{\omega_O}{3}$$

А $T_n$ - задача с минимальным временем выполнения, значит $\forall{i} : T_i > \frac{\omega_O}{3}$

Значит на каждой машине выполняется не больше 2 задач

Теперь осталось заметить, что если у нас $n \meq 2m$, то наш алгоритм будет работать не хуже оптимального, так как первые $m$ задач разложит на каждую машину, а потом $m + i$ задачу будет класть к $m - i + 1$ с точностью до задач с одинаковым временем выполнения. Далее от перестановки верхнего слоя ответ не будет улучшаться (если мы меняем верхние задачи, то максимальная сумма увеличивается. Просортируем задачи по убыванию времени выполнения. Так как у нас первый и последняя задача были на одной машине, а 2-ая и 3-яя на другой из алгоритма, а теперь 1-ая и 2-ая будут на одной машине, то ответ не уменьшится). А можно заметить что обязательно есть оптимальное решение, где в нижнем слою будут первые $m$ элементов. Иначе можно прийти к этому не ухудшив решение.

\end{proof}

При проверки алгоритма на практике он оказался достаточно быстрым и при $10^6$ задачах и $10^6$ машин выполнялся за 1.8 секунды.

\renewcommand{\refname}{Библиография}
\bibliographystyle{plainnat}
\bibliography{references}
\end{document}
